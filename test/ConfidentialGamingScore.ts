import { expect } from "chai";
import { ethers } from "hardhat";
import { ConfidentialGamingScore } from "../typechain-types";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { createInstance } from "fhevmjs";

/**
 * Test Suite: ConfidentialGamingScore
 *
 * This test suite demonstrates:
 * - Player registration and score submission
 * - Encrypted score handling
 * - Privacy-preserving computations
 * - Achievement system
 * - Network statistics
 * - Common pitfalls and error cases
 */
describe("ConfidentialGamingScore", function () {
  let contract: ConfidentialGamingScore;
  let owner: SignerWithAddress;
  let player1: SignerWithAddress;
  let player2: SignerWithAddress;
  let player3: SignerWithAddress;
  let fhevm: any;

  /**
   * Setup: Deploy contract and initialize FHE environment
   */
  beforeEach(async function () {
    // Get signers
    [owner, player1, player2, player3] = await ethers.getSigners();

    // Deploy contract
    const ConfidentialGamingScoreFactory = await ethers.getContractFactory(
      "ConfidentialGamingScore"
    );
    contract = await ConfidentialGamingScoreFactory.deploy();
    await contract.waitForDeployment();

    // Initialize FHEVM instance
    try {
      fhevm = await createInstance({
        chainId: 31337,
        networkUrl: "http://localhost:8545",
      });
    } catch (error) {
      console.log("Note: FHEVM instance initialization in test environment");
    }
  });

  // ==================== Registration Tests ====================

  describe("Player Registration", function () {
    /**
     * ✅ Test: Player can register successfully
     */
    it("Should allow player registration", async function () {
      const tx = await contract.connect(player1).registerPlayer();
      await tx.wait();

      const isRegistered = await contract.isPlayerRegistered(player1.address);
      expect(isRegistered).to.be.true;
    });

    /**
     * ✅ Test: Registry updates correctly
     */
    it("Should update player registry on registration", async function () {
      await contract.connect(player1).registerPlayer();
      await contract.connect(player2).registerPlayer();

      const registry = await contract.getPlayerRegistry();
      expect(registry.length).to.equal(2);
      expect(registry[0]).to.equal(player1.address);
      expect(registry[1]).to.equal(player2.address);
    });

    /**
     * ❌ Test: Prevent duplicate registration
     *
     * Common pitfall: Attempting to register multiple times
     * Expected behavior: Second registration should fail
     */
    it("Should prevent duplicate player registration", async function () {
      await contract.connect(player1).registerPlayer();

      // Attempt second registration
      await expect(
        contract.connect(player1).registerPlayer()
      ).to.be.revertedWith("Player already registered");
    });

    /**
     * ❌ Test: Prevent registration from zero address
     */
    it("Should reject registration from invalid address", async function () {
      // This test would require creating a transaction from address(0)
      // which is not directly possible in normal test environment
      // but the contract checks for it
      expect(
        await contract.isPlayerRegistered(ethers.ZeroAddress)
      ).to.be.false;
    });
  });

  // ==================== Score Submission Tests ====================

  describe("Score Submission", function () {
    beforeEach(async function () {
      // Register players before each test
      await contract.connect(player1).registerPlayer();
      await contract.connect(player2).registerPlayer();
    });

    /**
     * ✅ Test: Registered player can submit encrypted score
     */
    it("Should allow registered player to submit score", async function () {
      // Simulate encrypted input (in real environment, generated by FHE client)
      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      const tx = await contract.connect(player1).submitScore(
        mockEncryptedScore,
        mockProof
      );
      await tx.wait();

      const hasScore = await contract.hasPlayerSubmitted(player1.address);
      expect(hasScore).to.be.true;
    });

    /**
     * ✅ Test: Total player count increases on first submission
     */
    it("Should increment total players on first score submission", async function () {
      const initialCount = await contract.getTotalPlayers();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(
        mockEncryptedScore,
        mockProof
      );

      const newCount = await contract.getTotalPlayers();
      expect(newCount).to.equal(initialCount.add(1));
    });

    /**
     * ✅ Test: Multiple players can submit scores
     */
    it("Should handle multiple player submissions", async function () {
      const mockEncryptedScore1 = ethers.toBeHex(1500, 32);
      const mockEncryptedScore2 = ethers.toBeHex(2000, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(mockEncryptedScore1, mockProof);
      await contract.connect(player2).submitScore(mockEncryptedScore2, mockProof);

      expect(await contract.hasPlayerSubmitted(player1.address)).to.be.true;
      expect(await contract.hasPlayerSubmitted(player2.address)).to.be.true;

      const totalCount = await contract.getTotalPlayers();
      expect(totalCount).to.equal(2);
    });

    /**
     * ❌ Test: Non-registered player cannot submit score
     *
     * Common pitfall: Forgetting to register before submitting
     * Expected behavior: Should fail with "Player not registered"
     */
    it("Should reject score submission from non-registered player", async function () {
      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await expect(
        contract.connect(player3).submitScore(mockEncryptedScore, mockProof)
      ).to.be.revertedWith("Player not registered");
    });

    /**
     * ❌ Test: Reject submission with empty encrypted input
     */
    it("Should reject empty encrypted input", async function () {
      const emptyInput = "0x";
      const mockProof = "0x" + "00".repeat(32);

      await expect(
        contract.connect(player1).submitScore(emptyInput, mockProof)
      ).to.be.revertedWith("Invalid encrypted input");
    });

    /**
     * ❌ Test: Reject submission with empty proof
     */
    it("Should reject empty proof", async function () {
      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const emptyProof = "0x";

      await expect(
        contract.connect(player1).submitScore(mockEncryptedScore, emptyProof)
      ).to.be.revertedWith("Invalid proof");
    });

    /**
     * ✅ Test: Player can update their score
     */
    it("Should allow player to update their score", async function () {
      const mockEncryptedScore1 = ethers.toBeHex(1500, 32);
      const mockEncryptedScore2 = ethers.toBeHex(2500, 32);
      const mockProof = "0x" + "00".repeat(32);

      // First submission
      await contract.connect(player1).submitScore(mockEncryptedScore1, mockProof);
      let hasScore = await contract.hasPlayerSubmitted(player1.address);
      expect(hasScore).to.be.true;

      // Update with new score
      await contract.connect(player1).submitScore(mockEncryptedScore2, mockProof);
      hasScore = await contract.hasPlayerSubmitted(player1.address);
      expect(hasScore).to.be.true;

      // Total count should still be 1 (update, not new submission)
      const totalCount = await contract.getTotalPlayers();
      expect(totalCount).to.equal(1);
    });
  });

  // ==================== Score Query Tests ====================

  describe("Score Queries", function () {
    beforeEach(async function () {
      await contract.connect(player1).registerPlayer();
      await contract.connect(player2).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(mockEncryptedScore, mockProof);
    });

    /**
     * ✅ Test: Player with score can query their encrypted score
     */
    it("Should return encrypted score for player with submission", async function () {
      const score = await contract.connect(player1).getMyScore();
      expect(score).to.not.be.null;
    });

    /**
     * ❌ Test: Player without score cannot query
     *
     * Common pitfall: Querying score before submission
     * Expected behavior: Should fail with "No score submitted"
     */
    it("Should reject score query from player without submission", async function () {
      await expect(
        contract.connect(player2).getMyScore()
      ).to.be.revertedWith("No score submitted");
    });

    /**
     * ✅ Test: Check if player has submitted
     */
    it("Should correctly identify players with scores", async function () {
      expect(await contract.hasPlayerSubmitted(player1.address)).to.be.true;
      expect(await contract.hasPlayerSubmitted(player2.address)).to.be.false;
    });

    /**
     * ✅ Test: Get total players count
     */
    it("Should return correct total player count", async function () {
      const count = await contract.getTotalPlayers();
      expect(count).to.equal(1);
    });
  });

  // ==================== Achievement System Tests ====================

  describe("Achievement System", function () {
    beforeEach(async function () {
      await contract.connect(player1).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);
      await contract.connect(player1).submitScore(mockEncryptedScore, mockProof);
    });

    /**
     * ✅ Test: Owner can create achievements
     */
    it("Should allow owner to create achievements", async function () {
      const tx = await contract.connect(owner).createAchievement(
        "High Scorer",
        1000
      );
      await tx.wait();

      const achievement = await contract.getAchievement(0);
      expect(achievement.title).to.equal("High Scorer");
      expect(achievement.requiredScore).to.equal(1000);
      expect(achievement.active).to.be.true;
    });

    /**
     * ❌ Test: Non-owner cannot create achievements
     */
    it("Should prevent non-owner from creating achievements", async function () {
      await expect(
        contract.connect(player1).createAchievement("Hacker", 999)
      ).to.be.revertedWithCustomError(contract, "OwnableUnauthorizedAccount");
    });

    /**
     * ❌ Test: Reject empty achievement title
     */
    it("Should reject empty achievement title", async function () {
      await expect(
        contract.connect(owner).createAchievement("", 1000)
      ).to.be.revertedWith("Empty title");
    });

    /**
     * ❌ Test: Reject zero required score
     */
    it("Should reject zero required score", async function () {
      await expect(
        contract.connect(owner).createAchievement("Invalid", 0)
      ).to.be.revertedWith("Invalid score");
    });

    /**
     * ✅ Test: Get achievement details
     */
    it("Should return achievement details", async function () {
      await contract.connect(owner).createAchievement("Master Player", 5000);

      const achievement = await contract.getAchievement(0);
      expect(achievement.title).to.equal("Master Player");
      expect(achievement.requiredScore).to.equal(5000);
    });

    /**
     * ❌ Test: Reject invalid achievement ID
     */
    it("Should reject invalid achievement ID", async function () {
      await expect(
        contract.connect(player1).hasAchievement(999)
      ).to.be.revertedWith("Invalid achievement");
    });
  });

  // ==================== Network Statistics Tests ====================

  describe("Network Statistics", function () {
    /**
     * ✅ Test: Get network statistics with no players
     */
    it("Should return correct stats with zero players", async function () {
      const stats = await contract.getNetworkStats();
      expect(stats).to.equal(0);
    });

    /**
     * ✅ Test: Get network statistics with multiple players
     */
    it("Should return correct stats with multiple players", async function () {
      await contract.connect(player1).registerPlayer();
      await contract.connect(player2).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(mockEncryptedScore, mockProof);
      await contract.connect(player2).submitScore(mockEncryptedScore, mockProof);

      const stats = await contract.getNetworkStats();
      expect(stats).to.equal(2);
    });
  });

  // ==================== Score Reset Tests ====================

  describe("Score Reset Functionality", function () {
    beforeEach(async function () {
      await contract.connect(player1).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(mockEncryptedScore, mockProof);
    });

    /**
     * ✅ Test: Player can reset their score
     */
    it("Should allow player to reset their score", async function () {
      const initialCount = await contract.getTotalPlayers();

      const tx = await contract.connect(player1).resetMyScore();
      await tx.wait();

      const hasScore = await contract.hasPlayerSubmitted(player1.address);
      expect(hasScore).to.be.false;

      const newCount = await contract.getTotalPlayers();
      expect(newCount).to.equal(initialCount.sub(1));
    });

    /**
     * ❌ Test: Cannot reset score if no score exists
     */
    it("Should reject reset if no score submitted", async function () {
      await contract.connect(player1).resetMyScore();

      await expect(
        contract.connect(player1).resetMyScore()
      ).to.be.revertedWith("No score to reset");
    });

    /**
     * ✅ Test: Player can resubmit after reset
     */
    it("Should allow resubmission after reset", async function () {
      await contract.connect(player1).resetMyScore();

      const mockEncryptedScore = ethers.toBeHex(2000, 32);
      const mockProof = "0x" + "00".repeat(32);

      const tx = await contract.connect(player1).submitScore(
        mockEncryptedScore,
        mockProof
      );
      await tx.wait();

      expect(await contract.hasPlayerSubmitted(player1.address)).to.be.true;
    });
  });

  // ==================== Contract Information Tests ====================

  describe("Contract Information", function () {
    /**
     * ✅ Test: Get contract information
     */
    it("Should return contract info", async function () {
      const info = await contract.getContractInfo();
      expect(info).to.include("ConfidentialGamingScore");
      expect(info).to.include("FHEVM");
    });

    /**
     * ✅ Test: Get minimum score threshold
     */
    it("Should return default minimum score threshold", async function () {
      const threshold = await contract.getMinScoreThreshold();
      expect(threshold).to.equal(100);
    });

    /**
     * ✅ Test: Owner can update minimum threshold
     */
    it("Should allow owner to update threshold", async function () {
      const tx = await contract.connect(owner).setMinScoreThreshold(500);
      await tx.wait();

      const newThreshold = await contract.getMinScoreThreshold();
      expect(newThreshold).to.equal(500);
    });

    /**
     * ❌ Test: Reject invalid threshold
     */
    it("Should reject invalid threshold", async function () {
      await expect(
        contract.connect(owner).setMinScoreThreshold(0)
      ).to.be.revertedWith("Invalid threshold");
    });
  });

  // ==================== Emergency Functions Tests ====================

  describe("Emergency Functions", function () {
    beforeEach(async function () {
      await contract.connect(player1).registerPlayer();
      await contract.connect(player2).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(mockEncryptedScore, mockProof);
      await contract.connect(player2).submitScore(mockEncryptedScore, mockProof);
    });

    /**
     * ✅ Test: Owner can perform emergency reset
     */
    it("Should allow owner to reset all data", async function () {
      let totalPlayers = await contract.getTotalPlayers();
      expect(totalPlayers).to.equal(2);

      const tx = await contract.connect(owner).emergencyReset();
      await tx.wait();

      totalPlayers = await contract.getTotalPlayers();
      expect(totalPlayers).to.equal(0);
    });

    /**
     * ❌ Test: Non-owner cannot perform emergency reset
     */
    it("Should prevent non-owner from emergency reset", async function () {
      await expect(
        contract.connect(player1).emergencyReset()
      ).to.be.revertedWithCustomError(contract, "OwnableUnauthorizedAccount");
    });
  });

  // ==================== Edge Case Tests ====================

  describe("Edge Cases", function () {
    /**
     * ✅ Test: Handle large number of players
     */
    it("Should handle many player registrations", async function () {
      const signers = await ethers.getSigners();
      const playerCount = 20;

      for (let i = 0; i < playerCount && i < signers.length - 3; i++) {
        await contract.connect(signers[i + 3]).registerPlayer();
      }

      const registry = await contract.getPlayerRegistry();
      expect(registry.length).to.equal(playerCount);
    });

    /**
     * ✅ Test: Handle many achievements
     */
    it("Should handle multiple achievements", async function () {
      const achievementCount = 10;

      for (let i = 0; i < achievementCount; i++) {
        await contract.connect(owner).createAchievement(
          `Achievement ${i}`,
          (i + 1) * 100
        );
      }

      const lastAchievement = await contract.getAchievement(achievementCount - 1);
      expect(lastAchievement.title).to.equal(`Achievement ${achievementCount - 1}`);
    });
  });

  // ==================== FHE-Specific Tests ====================

  describe("FHE Operations", function () {
    beforeEach(async function () {
      await contract.connect(player1).registerPlayer();
      await contract.connect(player2).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      await contract.connect(player1).submitScore(mockEncryptedScore, mockProof);
      await contract.connect(player2).submitScore(mockEncryptedScore, mockProof);
    });

    /**
     * ✅ Test: Encrypted comparison operations
     */
    it("Should support encrypted comparisons", async function () {
      const result = await contract.connect(player1).meetsAchievementThreshold(1000);
      expect(result).to.not.be.null;
    });

    /**
     * ✅ Test: Score comparison between players
     */
    it("Should support encrypted score comparison", async function () {
      const result = await contract
        .connect(player1)
        .isScoreHigherThan(player2.address);
      expect(result).to.not.be.null;
    });

    /**
     * ❌ Test: Cannot compare with unregistered player
     */
    it("Should reject comparison with unregistered player", async function () {
      await expect(
        contract.connect(player1).isScoreHigherThan(player3.address)
      ).to.be.revertedWith("Other player not registered");
    });

    /**
     * ✅ Test: Approximate leaderboard position
     */
    it("Should return approximate leaderboard position", async function () {
      const position = await contract
        .connect(player1)
        .getApproximateLeaderboardPosition();
      expect(position).to.not.be.null;
    });
  });

  // ==================== Events Tests ====================

  describe("Contract Events", function () {
    /**
     * ✅ Test: PlayerRegistered event is emitted
     */
    it("Should emit PlayerRegistered event", async function () {
      const tx = await contract.connect(player1).registerPlayer();
      const receipt = await tx.wait();

      const events = receipt?.logs.filter((log) => {
        try {
          return contract.interface.parseLog(log)?.name === "PlayerRegistered";
        } catch {
          return false;
        }
      });

      expect(events?.length).to.be.greaterThan(0);
    });

    /**
     * ✅ Test: ConfidentialScoreSubmitted event is emitted
     */
    it("Should emit ConfidentialScoreSubmitted event", async function () {
      await contract.connect(player1).registerPlayer();

      const mockEncryptedScore = ethers.toBeHex(1500, 32);
      const mockProof = "0x" + "00".repeat(32);

      const tx = await contract
        .connect(player1)
        .submitScore(mockEncryptedScore, mockProof);
      const receipt = await tx.wait();

      const events = receipt?.logs.filter((log) => {
        try {
          const parsed = contract.interface.parseLog(log);
          return parsed?.name === "ConfidentialScoreSubmitted";
        } catch {
          return false;
        }
      });

      expect(events?.length).to.be.greaterThan(0);
    });
  });
});
